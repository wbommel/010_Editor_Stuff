//------------------------------------------------
//--- 010 Editor v9.0.1 Binary Template
//
//      File: adf.bt
//   Authors: Volker Broemmel
//   Version: 0.0.1
//   Purpose: 
//  Category: 
// File Mask: *.adf
//  ID Bytes: 
//   History: 
//------------------------------------------------


// Define constants
const int BSIZE		= 512;				// sizeof a disc sector in bytes
const int HT_SIZE	= BSIZE / 4 - 56;	//



// Boot block structure
typedef struct {
	uchar		DiskType[3]				<comment="'D''O''S' + flags",fgcolor=cPurple,bgcolor=cRed>;
	uchar		flags					<format=binary,comment=_getDiscFlagsString>;
	ulong		chksum					<format=hex,comment="special block checksum",fgcolor=cAqua,bgcolor=cWhite>;
	ulong		Rootblock				<comment="Value is 880 for DD and HD",fgcolor=cLtYellow,bgcolor=cBlack>;
	uchar		Bootblock_code[1012]	<comment="BOOT_CODE",fgcolor=cWhite,bgcolor=cBlack>;
} BOOTBLOCK <bgcolor=cGray,comment="Boot block">;

// Root block structure
typedef struct {
	ulong		type					<comment="block primary type = T_HEADER (value 2)">;
	ulong		header_key				<comment="unused in rootblock (value 0)">;
	ulong		high_seq				<comment="unused (value 0)">;
	ulong		ht_size					<comment="Hash table size in long (= BSIZE/4 - 56). For floppy disk value 0x48">;
	ulong		first_data				<comment="unused (value 0)">;
	ulong		chksum					<format=hex,comment="Rootblock checksum">;
	ulong		ht[HT_SIZE]				<comment="hash table (entry block number) (= (BSIZE/4) - 56) for floppy disk: size= 72 longwords">;
	ulong		bm_flag					<comment="bitmap flag, -1 means VALID">;
	ulong		bm_pages[25]			<comment="bitmap blocks pointers (first one at bm_pages[0])">;
	ulong		bm_ext					<comment="first bitmap extension block (Hard disks only)">;
	ulong		r_days					<comment="last root alteration date (days since 1 jan 78)">;
	ulong		r_mins					<comment="minutes past midnight">;
	ulong		r_ticks					<comment="ticks (1/50 sec) past last minute">;
	uchar		name_len				<comment="volume name length">;
	uchar		diskname[30]			<comment="volume name">;
	uchar		UNUSED					<comment="set to 0">;
	ulong		UNUSED					<comment="set to 0">;
	ulong		UNUSED					<comment="set to 0">;
	ulong		v_days					<comment="last disk alteration date (days since 1 jan 78)">;
	ulong		v_mins					<comment="minutes past midnight">;
	ulong		v_ticks					<comment="ticks (1/50 sec) past last minute">;
	ulong		c_days					<comment="filesystem creation date (days since 1 jan 78)">;
	ulong		c_mins					<comment="minutes past midnight">;
	ulong		c_ticks					<comment="ticks (1/50 sec) past last minute">;
	ulong		next_hash				<comment="unused (value = 0)">;
	ulong		parent_dir				<comment="unused (value = 0)">;
	ulong		extension				<comment="FFS: first directory cache block, 0 otherwise">;
	ulong		sec_type				<comment="block secondary type = ST_ROOT (value 1)">;
} ROOTBLOCK <bgcolor=cGray,comment="Root block">;

// File header block structure
typedef struct {
	ulong		type					<comment="block primary type T_HEADER (==2)">;
	ulong		header_key				<comment="self pointer (to this block)">;
	ulong		high_seq				<comment="number of data block ptr stored here">;
	ulong		data_size				<comment="unused (==0)">;
	ulong		first_data				<comment="first data block ptr">;
	ulong		chksum					<format=hex,comment="same algorithm as rootblock">;
	ulong		data_blocks[(BSIZE/4) - 56]	<comment="data blk ptr (first at BSIZE-204) = (BSIZE/4) - 56">;
	ulong		UNUSED					<comment="unused (==0)">;
	ushort		UID						<comment="UserID">;
	ushort		GID						<comment="GroupID">;
	ulong		protect					<comment="protection flags (set to 0 by default)">;
	ulong		byte_size				<comment="file size in bytes">;
	uchar		comm_len				<comment="file comment length">;
	uchar		comment[79]				<comment="comment (max. 79 chars permitted)">;
	uchar		UNUSED[12]				<comment="set to 0">;
	ulong		days					<comment="last change date (days since 1 jan 78)">;
	ulong		mins					<comment="last change time">;
	ulong		ticks					<comment="in 1/50s of a seconds">;
	uchar		name_len				<comment="filename length">;
	uchar		filename[30]			<comment="filename (max. 30 chars permitted)">;
	uchar		UNUSED					<comment="set to 0">;
	ulong		UNUSED					<comment="set to 0">;
	ulong		real_entry				<comment="FFS : unused (== 0)">;
	ulong		next_link				<comment="FFS : hardlinks chained list (first=newest)">;
	ulong		UNUSED[5]				<comment="set to 0">;
	ulong		hash_chain				<comment="next entry ptr with same hash">;
	ulong		parent					<comment="parent directory">;
	ulong		extension				<comment="pointer to 1st file extension block">;
	ulong		sec_type				<comment="secondary type : ST_FILE (== -3)">;
} FILEHEADERBLOCK <bgcolor=cGray,comment="File header block">;

// OFS data block structure
typedef struct {
	ulong		type					<comment="Block type">;
	ulong		header_key				<comment="Pointer to FileHeader block">;
	ulong		seq_num					<comment="file data block number (first is #1)">;
	ulong		data_size				<comment="data size <= (BSIZE-2">;
	ulong		next_data				<comment="next data block ptr (0 for last)">;
	ulong		chksum					<format=hex,comment="rootblock algorithm">;
	uchar		data[488]				<comment="file data size <= (BSIZE-24)">;
} DATABLOCK <comment="Data block (OFS)">; 




// <comment="">;





//--------------------------------------------
// Values in 68xxx CPU's are BigEndian
BigEndian();

// To save memory, allow a single copy of this template to provide 
//  syntax highlighting for all open files that match the file mask.
HighlightAllowInstanceSharing( true );

// Define the locals
local uchar sector[BSIZE];
local uchar bootblock[BSIZE * 2];
local int64 pos = 0;

local uchar ulongValue[4];



/*
 * function declarations
 */
// Loop through disc sectors sequentially
void _sequentialAproach() {
	while( !FEof() )
	{
	
		ReadBytes( sector, pos, BSIZE );
	
		//detect boot block
		if ( sector[0] == 'D' && sector[1] == 'O' && sector[2] == 'S' ) {
			ReadBytes( bootblock, pos, BSIZE * 2 );
			BOOTBLOCK typebootblock;
		}
	
		if ( sector[3] == 8 )
		{
			DATABLOCK typedatablock;
		}
	
		//set file cursor to next block
		pos += BSIZE;
		FSeek( pos );
	}
}

// Filesystem tree aproach
void _filesystemTreeAproach() {
	//read boot block
	ReadBytes( bootblock, 0, BSIZE * 2 );
	BOOTBLOCK typebootblock;

	//read root block
	local int rootPointer = 880; //standard value for root block is 880
	if ( typebootblock.Rootblock > 0 && typebootblock.Rootblock < 1760 ) { //1760 is maximum size of DD discs. HD is twice as much.
		rootPointer = typebootblock.Rootblock;
	}
	
	FSeek( rootPointer * BSIZE );
	ReadBytes( sector, rootPointer * BSIZE, BSIZE );
	ROOTBLOCK typerootblock;
	if ( typerootblock.type != 2 || typerootblock.sec_type != 1 ) {
		//typerootblock = 0;
	}


	Printf( "Boot block root pointer 1: %d\n", _getULongByPos_BigEndian( 8 ) );
	Printf( "Boot block root pointer 2: %d\n", typebootblock.Rootblock );
}



/*
 * helpers
 */
// get ulong values
ulong _getULongByPos_BigEndian( int pos ) {
	ReadBytes( ulongValue, pos, 4 );
	return (ulongValue[0] * Pow( 2, 32 )) + (ulongValue[1] * Pow( 2, 16 )) + (ulongValue[2] * Pow( 2, 8 )) + (ulongValue[3]);
}

// get disc type flags string
string _getDiscFlagsString( byte flags ) {
	string strFlags = "";

	if( ((flags) & (1<<(0))) ) {
		strFlags += "| FFS ";
	} else {
		strFlags += "| OFS ";
	}

	if( ((flags) & (1<<(1))) ) {
		strFlags += "| INTL ONLY ";
	} else {
		strFlags += "| NO_INTL ONLY ";
	}

	if( ((flags) & (1<<(2))) ) {
		strFlags += "| DIRC&INTL ";
	} else {
		strFlags += "| NO_DIRC&INTL ";
	}

	return strFlags;
}



/*
 * template action
 */
Printf( "Start template\n" );

//_sequentialAproach();
_filesystemTreeAproach();

Printf( "Template done\n" );
